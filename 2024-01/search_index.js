var documenterSearchIndex = {"docs":
[{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"EditURL = \"perfect_entanglers.jl\"","category":"page"},{"location":"examples/perfect_entanglers/#Entangling-quantum-gates-for-coupled-transmon-qubits","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"gdefOp1hat1 gdefop1hat1 gdefinittextinit gdeftgttexttgt gdefReoperatornameRe gdefImoperatornameIm","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"\ndatadir(names...) = joinpath(@__DIR__, names...);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"This example illustrates the optimization towards a perfectly entangling two-qubit gate for a system of two transmon qubits with a shared transmission line. It goes through three progressively more advanced optimizations:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The direct optimization for a OpO = sqrttextiSWAP gate with a standard square-modulus functional\nThe optimization towards a perfect entangler using the functional developed in Goerz et al., Phys. Rev. A 91, 062307 (2015)Â [1]\nThe direct maximization of of the gate concurrence","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"While the first example evaluates the gradient of the optimization functional analytically, the latter two are examples for the use of automatic differentiation, or more specifically semi-automatic differentiation, as developed in Goerz et al. [2]. The optimization of the gate concurrence specifically illustrates the optimization of a functional that is inherently non-analytical.","category":"page"},{"location":"examples/perfect_entanglers/#Hamiltonian-and-guess-pulses","page":"Entangling quantum gates for coupled transmon qubits","title":"Hamiltonian and guess pulses","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We will write the Hamiltonian in units of GHz (angular frequency; the factor 2Ï€ is implicit) and ns:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"const GHz = 2Ï€\nconst MHz = 0.001GHz\nconst ns = 1.0\nconst Î¼s = 1000ns;","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The Hamiltonian and parameters are taken from Ref.Â [1, Table 1].","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"âŠ— = kron\nconst ğ•š = 1im\nconst N = 6  # levels per transmon\n\nusing LinearAlgebra\nusing SparseArrays\nusing QuantumControl\n\n\nfunction transmon_hamiltonian(;\n    Î©re,\n    Î©im,\n    N=N,  # levels per transmon\n    Ï‰â‚=4.380GHz,\n    Ï‰â‚‚=4.614GHz,\n    Ï‰d=4.498GHz,\n    Î±â‚=-210MHz,\n    Î±â‚‚=-215MHz,\n    J=-3MHz,\n    Î»=1.03,\n    use_sparse=:auto\n)\n    ğŸ™ = SparseMatrixCSC{ComplexF64,Int64}(sparse(I, N, N))\n    bÌ‚â‚ = spdiagm(1 => complex.(sqrt.(collect(1:N-1)))) âŠ— ğŸ™\n    bÌ‚â‚‚ = ğŸ™ âŠ— spdiagm(1 => complex.(sqrt.(collect(1:N-1))))\n    bÌ‚â‚âº = sparse(bÌ‚â‚')\n    bÌ‚â‚‚âº = sparse(bÌ‚â‚‚')\n    nÌ‚â‚ = sparse(bÌ‚â‚' * bÌ‚â‚)\n    nÌ‚â‚‚ = sparse(bÌ‚â‚‚' * bÌ‚â‚‚)\n    nÌ‚â‚Â² = sparse(nÌ‚â‚ * nÌ‚â‚)\n    nÌ‚â‚‚Â² = sparse(nÌ‚â‚‚ * nÌ‚â‚‚)\n    bÌ‚â‚âº_bÌ‚â‚‚ = sparse(bÌ‚â‚' * bÌ‚â‚‚)\n    bÌ‚â‚_bÌ‚â‚‚âº = sparse(bÌ‚â‚ * bÌ‚â‚‚')\n\n    Ï‰Ìƒâ‚ = Ï‰â‚ - Ï‰d\n    Ï‰Ìƒâ‚‚ = Ï‰â‚‚ - Ï‰d\n\n    HÌ‚â‚€ = sparse(\n        (Ï‰Ìƒâ‚ - Î±â‚ / 2) * nÌ‚â‚ +\n        (Î±â‚ / 2) * nÌ‚â‚Â² +\n        (Ï‰Ìƒâ‚‚ - Î±â‚‚ / 2) * nÌ‚â‚‚ +\n        (Î±â‚‚ / 2) * nÌ‚â‚‚Â² +\n        J * (bÌ‚â‚âº_bÌ‚â‚‚ + bÌ‚â‚_bÌ‚â‚‚âº)\n    )\n\n    HÌ‚â‚re = (1 / 2) * (bÌ‚â‚ + bÌ‚â‚âº + Î» * bÌ‚â‚‚ + Î» * bÌ‚â‚‚âº)\n    HÌ‚â‚im = (ğ•š / 2) * (bÌ‚â‚âº - bÌ‚â‚ + Î» * bÌ‚â‚‚âº - Î» * bÌ‚â‚‚)\n\n    if ((N < 5) && (use_sparse â‰¢ true)) || use_sparse â‰¡ false\n        H = hamiltonian(Array(HÌ‚â‚€), (Array(HÌ‚â‚re), Î©re), (Array(HÌ‚â‚im), Î©im))\n    else\n        H = hamiltonian(HÌ‚â‚€, (HÌ‚â‚re, Î©re), (HÌ‚â‚im, Î©im))\n    end\n    return H\n\nend;","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We choose a pulse duration of 400 ns. The guess pulse amplitude is 35 MHz, with a 15 ns switch-on/-off time. This switch-on/-off must be maintained in the optimization: A pulse that does not start from or end at zero would not be physical. For GRAPE, we can achieve this by using a ShapedAmplitude:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using QuantumControl.Amplitudes: ShapedAmplitude","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"This allows to have a control amplitude Î©(t) = S(t) Ïµ(t) where S(t) is a fixed shape and Ïµ(t) is the pulse directly tuned by the optimization. We start with a constant Ïµ(t) and do not place any restrictions on how the optimization might update Ïµ(t).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The Hamiltonian is written in a rotating frame, so in general, the control field is allowed to be complex-valued. We separate this into two control fields, one for the real part and one for the imaginary part. Initially, the imaginary part is zero, corresponding to a field exactly at the frequency of the rotating frame.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Note that passing tlist to ShapedAmplitude discretizes both the control and the shape function to the midpoints of the tlist array.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using QuantumControl.Shapes: flattop\n\nfunction guess_amplitudes(; T=400ns, Eâ‚€=35MHz, dt=0.1ns, t_rise=15ns)\n\n    tlist = collect(range(0, T, step=dt))\n    shape(t) = flattop(t, T=T, t_rise=t_rise)\n    Î©re = ShapedAmplitude(t -> Eâ‚€, tlist; shape)\n    Î©im = ShapedAmplitude(t -> 0.0, tlist; shape)\n\n    return tlist, Î©re, Î©im\n\nend\n\ntlist, Î©re_guess, Î©im_guess = guess_amplitudes();","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We can visualize this:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)\nusing QuantumControl.Controls: discretize\n\nfunction plot_complex_pulse(tlist, Î©; time_unit=:ns, ampl_unit=:MHz, kwargs...)\n\n    Î© = discretize(Î©, tlist)  # make sure Î© is defined on *points* of `tlist`\n\n    ax1 = plot(\n        tlist ./ eval(time_unit),\n        abs.(Î©) ./ eval(ampl_unit);\n        label=\"|Î©|\",\n        xlabel=\"time ($time_unit)\",\n        ylabel=\"amplitude ($ampl_unit)\",\n        kwargs...\n    )\n\n    ax2 = plot(\n        tlist ./ eval(time_unit),\n        angle.(Î©) ./ Ï€;\n        label=\"Ï•(Î©)\",\n        xlabel=\"time ($time_unit)\",\n        ylabel=\"phase (Ï€)\"\n    )\n\n    plot(ax1, ax2, layout=(2, 1))\n\nend\n\nfig = plot_complex_pulse(tlist, Array(Î©re_guess) .+ ğ•š .* Array(Î©im_guess))","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"(Image: )","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We now instantiate the Hamiltonian with these control fields:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"H = transmon_hamiltonian(Î©re=Î©re_guess, Î©im=Î©im_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Generator{SparseArrays.SparseMatrixCSC{ComplexF64, Int64}, QuantumPropagators.Amplitudes.ShapedPulseAmplitude}(<3 ops>, <2 amplitudes>)","category":"page"},{"location":"examples/perfect_entanglers/#Logical-basis-for-two-qubit-gates","page":"Entangling quantum gates for coupled transmon qubits","title":"Logical basis for two-qubit gates","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"For simplicity, we will be define the qubits in the bare basis, i.e. ignoring the static coupling J.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"function ket(i::Int64; N=N)\n    Î¨ = zeros(ComplexF64, N)\n    Î¨[i+1] = 1\n    return Î¨\nend\n\nfunction ket(indices::Int64...; N=N)\n    Î¨ = ket(indices[1]; N=N)\n    for i in indices[2:end]\n        Î¨ = Î¨ âŠ— ket(i; N=N)\n    end\n    return Î¨\nend\n\nfunction ket(label::AbstractString; N=N)\n    indices = [parse(Int64, digit) for digit in label]\n    return ket(indices...; N=N)\nend;","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"basis = [ket(\"00\"), ket(\"01\"), ket(\"10\"), ket(\"11\")];","category":"page"},{"location":"examples/perfect_entanglers/#Optimizing-for-a-specific-quantum-gate","page":"Entangling quantum gates for coupled transmon qubits","title":"Optimizing for a specific quantum gate","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Our target gate is OpO = sqrttextiSWAP:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"SQRTISWAP = [\n    1  0    0   0\n    0 1/âˆš2 ğ•š/âˆš2 0\n    0 ğ•š/âˆš2 1/âˆš2 0\n    0  0    0   1\n];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"For each basis state, we get a target state that results from applying the gate to the basis state (you can convince yourself that this equivalent multiplying the transpose of the above gate matrix to the vector of basis states):","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"basis_tgt = transpose(SQRTISWAP) * basis;","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The mapping from each initial (basis) state to the corresponding target state constitutes an \"objective\" for the optimization:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"objectives = [\n    Objective(initial_state=Î¨, target_state=Î¨tgt, generator=H) for\n    (Î¨, Î¨tgt) âˆˆ zip(basis, basis_tgt)\n];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We can analyze how all of the basis states evolve under the guess controls in one go:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using QuantumPropagators: Cheby\n\nguess_states = propagate_objectives(objectives, tlist; method=Cheby, use_threads=true);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The gate implemented by the guess controls is","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"U_guess = [basis[i] â‹… guess_states[j] for i = 1:4, j = 1:4];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We will optimize these objectives with a square-modulus functional","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using QuantumControl.Functionals: J_T_sm","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The initial value of the functional is","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"J_T_sm(guess_states, objectives)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.9156372510989136","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"which is the gate error","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"1 - (abs(tr(U_guess' * SQRTISWAP)) / 4)^2","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.9156372510989136","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Now, we define the full optimization problems on top of the list of objectives, and with the optimization functional:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"problem = ControlProblem(\n    objectives=objectives,\n    tlist=tlist,\n    iter_stop=100,\n    J_T=J_T_sm,\n    check_convergence=res -> begin\n        (\n            (res.J_T > res.J_T_prev) &&\n            (res.converged = true) &&\n            (res.message = \"Loss of monotonic convergence\")\n        )\n        ((res.J_T <= 1e-3) && (res.converged = true) && (res.message = \"J_T < 10â»Â³\"))\n    end,\n    prop_method=Cheby,\n    use_threads=true,\n);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_result = @optimize_or_load(datadir(\"GRAPE_GATE_OCT.jld2\"), problem; method=:GRAPE);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/examples/perfect_entanglers/GRAPE_GATE_OCT.jld2 on unexpected exit.\n iter.        J_T     |âˆ‡J_T|       Î”J_T   FG(F)    secs\n     0   9.16e-01   1.41e-01        n/a    1(0)     6.8\n     1   8.94e-01   2.36e-01  -2.19e-02    1(0)     0.4\n     2   8.85e-01   6.54e-01  -8.30e-03    1(0)     0.3\n     3   8.52e-01   4.18e-01  -3.35e-02    1(0)     0.3\n     4   7.97e-01   9.12e-01  -5.47e-02    1(0)     0.4\n     5   5.81e-01   1.15e+00  -2.16e-01    2(0)     0.8\n     6   4.49e-01   6.34e-01  -1.32e-01    2(0)     0.7\n     7   4.27e-01   4.43e-01  -2.16e-02    2(0)     0.6\n     8   3.97e-01   4.53e-01  -3.06e-02    1(0)     0.3\n     9   2.82e-01   1.28e+00  -1.15e-01    1(0)     0.4\n    10   1.96e-01   6.70e-01  -8.51e-02    1(0)     0.4\n    11   1.83e-01   8.17e-01  -1.31e-02    1(0)     0.4\n    12   1.61e-01   3.98e-01  -2.23e-02    1(0)     0.3\n    13   1.53e-01   2.25e-01  -7.98e-03    1(0)     0.3\n    14   1.42e-01   2.2â€¦\n    21   4.14e-02   1.76e-01  -5.42e-03    1(0)     0.3\n    22   3.60e-02   2.23e-01  -5.39e-03    1(0)     0.4\n    23   2.70e-02   2.05e-01  -9.05e-03    1(0)     0.4\n    24   2.38e-02   2.15e-01  -3.19e-03    2(0)     0.7\n    25   1.99e-02   1.01e-01  -3.86e-03    1(0)     0.3\n    26   1.78e-02   9.93e-02  -2.16e-03    1(0)     0.3\n    27   1.51e-02   1.25e-01  -2.66e-03    1(0)     0.3\n    28   1.24e-02   1.62e-01  -2.66e-03    1(0)     0.4\n    29   9.81e-03   7.46e-02  -2.63e-03    1(0)     0.3\n    30   8.35e-03   7.97e-02  -1.47e-03    1(0)     0.3\n    31   6.35e-03   1.03e-01  -1.99e-03    1(0)     0.3\n    32   4.71e-03   1.59e-01  -1.64e-03    1(0)     0.3\n    33   3.51e-03   9.26e-02  -1.20e-03    1(0)     0.3\n    34   2.80e-03   5.79e-02  -7.10e-04    1(0)     0.3\n    35   2.25e-03   6.23e-02  -5.45e-04    1(0)     0.3\n    36   1.89e-03   5.80e-02  -3.66e-04    1(0)     0.3\n    37   1.23e-03   5.28e-02  -6.62e-04    1(0)     0.3\n    38   6.91e-04   5.09e-02  -5.36e-04    1(0)     0.3\n\n","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_result","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"GRAPE Optimization Result\n-------------------------\n- Started at 2024-01-17T16:35:19.164\n- Number of objectives: 4\n- Number of iterations: 38\n- Number of pure func evals: 0\n- Number of func/grad evals: 43\n- Value of functional: 6.91035e-04\n- Reason for termination: J_T < 10â»Â³\n- Ended at 2024-01-17T16:35:40.392 (21 seconds, 228 milliseconds)\n","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We extract the optimized control field from the optimization result and plot the resulting amplitude.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The optimized_controls field of the opt_results contains the optimized controls Ïµ(t).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Ïµ_opt = opt_result.optimized_controls[1] + ğ•š * opt_result.optimized_controls[2];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"These must still be multiplied by the static shape S(t) that we set up for the guess amplitudes","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Î©_opt = Ïµ_opt .* discretize(Î©re_guess.shape, tlist)\n\nfig = plot_complex_pulse(tlist, Î©_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"(Image: )","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We then propagate the optimized control field to analyze the resulting quantum gate:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using QuantumControl.Controls: get_controls, substitute\n\nopt_states = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))\n    ),\n    tlist;\n    method=Cheby,\n    use_threads=true\n);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The resulting gate is","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"U_opt = [basis[i] â‹… opt_states[j] for i = 1:4, j = 1:4];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"and we can verify the resulting fidelity","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"(abs(tr(U_opt' * SQRTISWAP)) / 4)^2","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.9993089645810492","category":"page"},{"location":"examples/perfect_entanglers/#Optimizing-for-a-general-perfect-entangler","page":"Entangling quantum gates for coupled transmon qubits","title":"Optimizing for a general perfect entangler","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We define the optimization with one objective for each of the four basis states:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"objectives = [Objective(; initial_state=Î¨, generator=H) for Î¨ âˆˆ basis];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Note that we omit the target_state here. This is because we will be optimizing for an arbitrary perfect entangler, not for a specific quantum gate. Thus, there is no a-priori known target state to which the initial state must evolve.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The optimization is steered by the perfect entanglers distance measure D_PE, that is, the geometric distance of the quantum gate obtained from propagating the four basis states to the polyhedron of perfect entanglers in the Weyl chamber. Since the logical subspace defining the qubit is embedded in the larger Hilbert space of the transmon, there may be loss of population from the logical subspace. To counter this possibility in the optimization, we add a unitarity measure  to D_PE. The two terms are added with equal weight.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using TwoQubitWeylChamber: D_PE, gate_concurrence, unitarity\nusing QuantumControl.Functionals: gate_functional\n\nJ_T_PE = gate_functional(D_PE; unitarity_weight=0.5);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The gate_functional routines used above converts the function D_PE that receives the gate U as a 4Ã—4 matrix into a functional of the correct from for the QuantumControl.optimize routine, which is a function of the propagated states.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We can check that for the guess pulse, we are not implementing a perfect entangler","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"gate_concurrence(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.7773116198516767","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We find that the guess pulse produces a gate in the W0* region of the Weyl chamber:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using TwoQubitWeylChamber: weyl_chamber_region\nweyl_chamber_region(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"\"W0*\"","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"That is, the region of the Weyl chamber containing controlled-phase gates with a phase  Ï€ (Weyl chamber coordinates câ‚  Ï€2, câ‚‚  Ï€4).","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"This in fact allows use to use the perfect entangler functional without modification: if the guess pulse were in the \"W1\" region of the Weyl chamber, (close to SWAP), we would have to flip its sign, or we would optimize towards the local equivalence class of the SWAP gate instead of towards the perfect of perfect entanglers. In principle, we could use a modified functional that takes the absolute square of the D_PE term, by using","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"J_T_PE = gate_functional(D_PE; unitarity_weight=0.5, absolute_square=true)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"This would specifically optimize for the surface of the perfect entanglers functional.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"The guess pulse loses about 10% of population from the logical subspace:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"1 - unitarity(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.09071664593827622","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We can also evaluate the geometric distance to the polyhedron of perfect entanglers in the Weyl chamber:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"D_PE(U_guess)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.7787454222382404","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Together with the unitarity measure, this is the initial value of the optimization functional:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.5 * D_PE(U_guess) + 0.5 * (1 - unitarity(U_guess))","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.4347310340882583","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"J_T_PE(guess_states, objectives)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.4347310340882583","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"For the standard functional J_T_sm used in the previous section, our GRAPE was able to automatically use an analytic implementation of the gradient. For the perfect-entanglers functional, an analytic gradient exist, but is very cumbersome to implement. Instead, we make use of semi-automatic differentiation. As shown in Goerz et al., arXiv:2205.15044, by evaluating the gradient via a chain rule in the propagated states, the dependency of the gradient on the final time functional is pushed into the boundary condition for the backward propagation, Ï‡_k = -J_TÏ•_k. We can further exploit that J_T is an explicit function of the two-qubit gate in the computational basis and use a chain rule with respect to the elements of the two-qubit gate U_kk. The remaining derivatives J_TU_kk are then obtained via automatic differentiation. This is set up via the make_gate_chi function,","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"using QuantumControl.Functionals: make_gate_chi\nchi_pe = make_gate_chi(D_PE, objectives; unitarity_weight=0.5);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"where the resulting chi_pe must be passed to the optimization.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Now, we formulate the full control problem","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"problem = ControlProblem(\n    objectives=objectives,\n    tlist=tlist,\n    iter_stop=100,\n    prop_method=Cheby,\n    J_T=J_T_PE,\n    chi=chi_pe,\n    check_convergence=res -> begin\n        (\n            (res.J_T > res.J_T_prev) &&\n            (res.converged = true) &&\n            (res.message = \"Loss of monotonic convergence\")\n        )\n        (\n            (res.J_T <= 1e-3) &&\n            (res.converged = true) &&\n            (res.message = \"Found a perfect entangler\")\n        )\n    end,\n    use_threads=true,\n);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"With this, we can easily find a solution to the control problem:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_result = @optimize_or_load(datadir(\"GRAPE_PE_OCT.jld2\"), problem; method=:GRAPE);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/examples/perfect_entanglers/GRAPE_PE_OCT.jld2 on unexpected exit.\n iter.        J_T     |âˆ‡J_T|       Î”J_T   FG(F)    secs\n     0   4.35e-01   3.92e-01        n/a    1(0)     1.2\n     1   3.35e-01   7.52e-01  -9.94e-02    1(0)     0.4\n     2   1.69e-01   3.19e-01  -1.67e-01    1(0)     0.4\n     3   1.43e-01   2.09e-01  -2.59e-02    1(0)     0.4\n     4   1.00e-01   2.24e-01  -4.24e-02    1(0)     0.3\n     5   5.72e-02   2.60e-01  -4.33e-02    2(0)     0.6\n     6   4.96e-02   5.41e-01  -7.51e-03    1(0)     0.3\n     7   7.82e-03   1.82e-01  -4.18e-02    1(0)     0.3\n     8  -4.26e-03   1.13e-01  -1.21e-02    1(0)     0.3\n\n","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_result","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"GRAPE Optimization Result\n-------------------------\n- Started at 2024-01-17T16:36:04.139\n- Number of objectives: 4\n- Number of iterations: 8\n- Number of pure func evals: 0\n- Number of func/grad evals: 10\n- Value of functional: -4.25769e-03\n- Reason for termination: Found a perfect entangler\n- Ended at 2024-01-17T16:36:08.509 (4 seconds, 370 milliseconds)\n","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We extract the optimized control field from the optimization result and plot it","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Ïµ_opt = opt_result.optimized_controls[1] + ğ•š * opt_result.optimized_controls[2]\nÎ©_opt = Ïµ_opt .* discretize(Î©re_guess.shape, tlist)\n\nfig = plot_complex_pulse(tlist, Î©_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"(Image: )","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We then propagate the optimized control field to analyze the resulting quantum gate:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_states = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result.optimized_controls))\n    ),\n    tlist;\n    method=Cheby,\n    use_threads=true\n);\n\nU_opt = [basis[i] â‹… opt_states[j] for i = 1:4, j = 1:4];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We find that we have achieved a perfect entangler:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"gate_concurrence(U_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"1.0","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Moreover, we have reduced the population loss to less than 4%","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"1 - unitarity(U_opt)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.035261694562481294","category":"page"},{"location":"examples/perfect_entanglers/#Direct-maximization-of-the-gate-concurrence","page":"Entangling quantum gates for coupled transmon qubits","title":"Direct maximization of the gate concurrence","text":"","category":"section"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"In the previous optimizations, we have optimized for a perfect entangler indirectly via a geometric function in the Weyl chamber. The entire reason that perfect entangler functional was formulated is because calculating the gate concurrence directly involves the eigenvalues of the unitary, see Kraus and Cirac [3] and Childs et al. [4], which are inherently non-analytic.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"However, since we are able to obtain gradient from automatic differentiation, this is no longer an insurmountable obstacle","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"We can define a functional for a given gate U that combines the gate concurrence and (as above) a unitarity measure to penalize loss of population from the logical subspace:","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"J_T_C(U) = 0.5 * (1 - gate_concurrence(U)) + 0.5 * (1 - unitarity(U));","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"In the optimization, we will convert this functional to one that takes the propagated states as arguments (via the gate_functional routine). Also, as before, we have to create a matching routine for the boundary condition Ï‡_k = -fracÏ•_k J_T of the backward-propagation via the make_gate_chi routine.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"Running this, we again are able to find a perfect entangler.","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_result_direct = @optimize_or_load(\n    datadir(\"GRAPE_PE_OCT_direct.jld2\"),\n    problem;\n    method=:GRAPE,\n    J_T=gate_functional(J_T_C),\n    chi=make_gate_chi(J_T_C, objectives)\n);","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/examples/perfect_entanglers/GRAPE_PE_OCT_direct.jld2 on unexpected exit.\n iter.        J_T     |âˆ‡J_T|       Î”J_T   FG(F)    secs\n     0   1.57e-01   1.42e-01        n/a    1(0)     1.2\n     1   1.46e-01   3.18e-01  -1.05e-02    1(0)     0.4\n     2   1.30e-01   2.86e-01  -1.61e-02    1(0)     0.4\n     3   8.10e-02   2.10e-01  -4.91e-02    2(0)     0.7\n     4   7.66e-02   3.79e-01  -4.41e-03    1(0)     0.3\n     5   4.89e-02   1.87e-01  -2.77e-02    1(0)     0.3\n     6   2.64e-02   2.11e-01  -2.25e-02    1(0)     0.3\n     7   7.54e-03   1.09e-01  -1.89e-02    1(0)     0.4\n     8   5.86e-03   1.98e-01  -1.68e-03    1(0)     0.7\n     9   3.00e-03   4.01e-02  -2.87e-03    1(0)     0.4\n    10   2.71e-03   2.72e-02  -2.88e-04    1(0)     0.4\n    11   2.21e-03   2.82e-02  -5.01e-04    1(0)     0.4\n    12   1.42e-03   2.46e-02  -7.84e-04    1(0)     0.4\n    13   3.24e-04   2.83e-02  -1.10e-03    1(0)     0.4\n\n","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_result_direct","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"GRAPE Optimization Result\n-------------------------\n- Started at 2024-01-17T16:36:20.139\n- Number of objectives: 4\n- Number of iterations: 13\n- Number of pure func evals: 0\n- Number of func/grad evals: 15\n- Value of functional: 3.24322e-04\n- Reason for termination: Found a perfect entangler\n- Ended at 2024-01-17T16:36:26.910 (6 seconds, 771 milliseconds)\n","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"opt_states_direct = propagate_objectives(\n    substitute(\n        objectives,\n        IdDict(zip(get_controls(objectives), opt_result_direct.optimized_controls))\n    ),\n    tlist;\n    method=Cheby,\n    use_threads=true\n);\n\nU_opt_direct = [basis[i] â‹… opt_states_direct[j] for i = 1:4, j = 1:4];","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"gate_concurrence(U_opt_direct)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"1.0","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"1 - unitarity(U_opt_direct)","category":"page"},{"location":"examples/perfect_entanglers/","page":"Entangling quantum gates for coupled transmon qubits","title":"Entangling quantum gates for coupled transmon qubits","text":"0.0006486436943351492","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M.Â H.Â Goerz, G.Â Gualdi, D.Â M.Â Reich, C.Â P.Â Koch, F.Â Motzoi, K.Â B.Â Whaley, J.Â Vala, M.Â M.Â MÃ¼ller, S.Â Montangero and T.Â Calarco. Optimizing for an arbitrary perfect entangler. II. Application. Phys.Â Rev.Â A 91, 062307 (2015).\n\n\n\nM.Â H.Â Goerz, S.Â C.Â Carrasco and V.Â S.Â Malinovsky. Quantum Optimal Control via Semi-Automatic Differentiation. Quantum 6, 871 (2022).\n\n\n\nB.Â Kraus and J.Â I.Â Cirac. Optimal Creation of Entanglement Using a Two-Qubit Gate. Phys.Â Rev.Â A 63, 062309 (2001).\n\n\n\nA.Â Childs, H.Â Haselgrove and M.Â Nielsen. Lower bounds on the complexity of simulating quantum gates. Phys.Â Rev.Â A 68, 052311 (2003).\n\n\n\n","category":"page"},{"location":"tutorials/#List-of-Tutorials","page":"List of Tutorials","title":"List of Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"List of Tutorials","title":"List of Tutorials","text":"Pages = [index_md for (title, index_md) in TUTORIALS]\nDepth = 1","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"EditURL = \"rho_3states.jl\"","category":"page"},{"location":"examples/rho_3states/#Optimization-of-a-Dissipative-Quantum-Gate","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"gdefop1hat1 gdefketbra12vert1ranglelangle2vert gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"This example illustrates the optimization for a quantum gate in an open quantum system, where the dynamics is governed by the Liouville-von Neumann equation.","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"datadir(names...) = joinpath(@__DIR__, names...);\n\nusing QuantumControl\nusing LinearAlgebra\nusing Serialization\nusing SparseArrays","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)","category":"page"},{"location":"examples/rho_3states/#The-two-transmon-system","page":"Optimization of a Dissipative Quantum Gate","title":"The two-transmon system","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"We will use internal units GHz and ns. Values in GHz contain an implicit factor 2 pi, and MHz and Î¼s are converted to GHz and ns, respectively:","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"const GHz = 2Ï€;\nconst MHz = 0.001GHz;\nconst ns = 1.0;\nconst Î¼s = 1000ns;\nconst ğ•š = 1im;","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"This implicit factor 2 pi is because frequencies (nu) convert to energies as E = h nu, but our propagation routines assume a unit hbar = 1 for energies. Thus, the factor h  hbar = 2 pi.","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"function transmon_liouvillian(\n    Î©re,\n    Î©im;\n    N=5,             # number of qubit levels\n    Ï‰â‚=4.3796GHz,    # qubit frequency 1\n    Ï‰â‚‚=4.6137GHz,    # qubit frequency 2\n    Ï‰d=4.4985GHz,    # drive frequency\n    Î´â‚=-239.3MHz,    # anharmonicity 1\n    Î´â‚‚=-242.8MHz,    # anharmonicity 2\n    J=-2.3MHz,       # effective qubit-qubit coupling\n    Î³â‚â‚=(1 / 38.0Î¼s),  # decay rate for qubit 1\n    Î³â‚â‚‚=(1 / 32.0Î¼s),  # decay rate for qubit 2\n    Î³â‚‚â‚=(1 / 29.5Î¼s),  # dephasing rate for qubit 1\n    Î³â‚‚â‚‚=(1 / 16.0Î¼s)  # dephasing time for qubit 2\n)\n\n    âŠ—(A, B) = kron(A, B)\n    ğŸ™ = SparseMatrixCSC{ComplexF64,Int64}(sparse(I, N, N))\n\n    bÌ‚â‚ = spdiagm(1 => complex.(sqrt.(collect(1:N-1)))) âŠ— ğŸ™\n    bÌ‚â‚‚ = ğŸ™ âŠ— spdiagm(1 => complex.(sqrt.(collect(1:N-1))))\n    bÌ‚â‚âº = sparse(bÌ‚â‚')\n    bÌ‚â‚‚âº = sparse(bÌ‚â‚‚')\n    nÌ‚â‚ = sparse(bÌ‚â‚' * bÌ‚â‚)\n    nÌ‚â‚‚ = sparse(bÌ‚â‚‚' * bÌ‚â‚‚)\n    nÌ‚â‚Â² = sparse(nÌ‚â‚ * nÌ‚â‚)\n    nÌ‚â‚‚Â² = sparse(nÌ‚â‚‚ * nÌ‚â‚‚)\n    bÌ‚â‚âº_bÌ‚â‚‚ = sparse(bÌ‚â‚' * bÌ‚â‚‚)\n    bÌ‚â‚_bÌ‚â‚‚âº = sparse(bÌ‚â‚ * bÌ‚â‚‚')\n\n    HÌ‚â‚€ = sparse(\n        (Ï‰â‚ - Ï‰d - Î´â‚ / 2) * nÌ‚â‚ +\n        (Î´â‚ / 2) * nÌ‚â‚Â² +\n        (Ï‰â‚‚ - Ï‰d - Î´â‚‚ / 2) * nÌ‚â‚‚ +\n        (Î´â‚‚ / 2) * nÌ‚â‚‚Â² +\n        J * (bÌ‚â‚âº_bÌ‚â‚‚ + bÌ‚â‚_bÌ‚â‚‚âº)\n    )\n\n    HÌ‚â‚re = (1 / 2) * (bÌ‚â‚ + bÌ‚â‚âº + bÌ‚â‚‚ + bÌ‚â‚‚âº)\n    HÌ‚â‚im = (ğ•š / 2) * (bÌ‚â‚âº - bÌ‚â‚ + bÌ‚â‚‚âº - bÌ‚â‚‚)\n\n    H = (HÌ‚â‚€, (HÌ‚â‚re, Î©re), (HÌ‚â‚im, Î©im))\n\n    c_ops = [âˆšÎ³â‚â‚ * bÌ‚â‚, âˆšÎ³â‚â‚‚ * bÌ‚â‚‚, âˆšÎ³â‚‚â‚ * nÌ‚â‚, âˆšÎ³â‚‚â‚‚ * nÌ‚â‚‚]\n\n    return liouvillian(H, c_ops; convention=:TDSE)\n\nend\n\nconst T = 400ns;\n\nÎ©re(t) = 35MHz * QuantumControl.Shapes.flattop(t; T=T, t_rise=20ns);\nÎ©im(t) = 0.0;\n\nL = transmon_liouvillian(Î©re, Î©im);\n\ntlist = collect(range(0, 400ns, length=2000));","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"The guess pulse looks as follows:","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"function plot_control(pulse::Vector, tlist)\n    plot(tlist, pulse, xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nplot_control(Ïµ::Function, tlist) = plot_control([Ïµ(t) for t in tlist], tlist);","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"fig = plot_control(Î©re, tlist)","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"(Image: )","category":"page"},{"location":"examples/rho_3states/#Optimization-objectives","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization objectives","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"Our target gate is opO = sqrttextiSWAP:","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"SQRTISWAP = [\n    1  0    0   0\n    0 1/âˆš2 ğ•š/âˆš2 0\n    0 ğ•š/âˆš2 1/âˆš2 0\n    0  0    0   1\n];","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"The key idea explored in the paper is that a set of three density matrices is sufficient to track the optimization","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"beginalign\noprho_1\n    = sum_i=1^d frac2 (d-i+1)d (d+1) ketbraii \noprho_2\n    = sum_ij=1^d frac1d ketbraij \noprho_3\n    = sum_i=1^d frac1d ketbraii\nendalign","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"In our case, d=4 for a two qubit-gate, and the keti, ketj are the canonical basis states ket00, ket01, ket10, ket11","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"function ket(i::Int64; N=5)\n    Î¨ = zeros(ComplexF64, N)\n    Î¨[i+1] = 1\n    return Î¨\nend;\n\nket(i::Int64, j::Int64; N=5) = kron(ket(i; N=N), ket(j; N=N));\n\nbra(args...; N=5) = adjoint(ket(args..., N=N));\n\nconst basis_labels = [(0, 0), (0, 1), (1, 0), (1, 1)];\nconst basis = [ket(labels...) for labels in basis_labels];\nconst d = length(basis);\n\nconst basis_tgt = [sum([SQRTISWAP[i, j] * basis[i] for i âˆˆ 1:d]) for j âˆˆ 1:d];\n\n\nconst ÏÌ‚â‚ =\n    sum([(2 * (d - i + 1) / (d * (d + 1))) * basis[i] * adjoint(basis[i]) for i âˆˆ 1:d]);\nconst ÏÌ‚â‚‚ = sum([(1 / d) * basis[i] * adjoint(basis[j]) for i âˆˆ 1:d for j âˆˆ 1:d]);\nconst ÏÌ‚â‚ƒ = sum([(1 / d) * basis[i] * adjoint(basis[i]) for i âˆˆ 1:d]);\n\nconst ÏÌ‚â‚_tgt = sum([\n    (2 * (d - i + 1) / (d * (d + 1))) * basis_tgt[i] * adjoint(basis_tgt[i]) for i âˆˆ 1:d\n]);\nconst ÏÌ‚â‚‚_tgt =\n    sum([(1 / d) * basis_tgt[i] * adjoint(basis_tgt[j]) for i âˆˆ 1:d for j âˆˆ 1:d]);\nconst ÏÌ‚â‚ƒ_tgt = sum([(1 / d) * basis_tgt[i] * adjoint(basis_tgt[i]) for i âˆˆ 1:d]);","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"The three density matrices play different roles in the optimization, and, as shown in the paper, convergence may improve significantly by weighing the states relatively to each other. For this example, we place a strong emphasis on the optimization oprho_1 rightarrow opO^dagger oprho_1 opO, by a factor of 20. This reflects that the hardest part of the optimization is identifying the basis in which the gate is diagonal. We will be using the real-part functional (J_Ttextre) to evaluate the success of oprho_i rightarrow opOoprho_iopO^dagger. Because oprho_1 and oprho_3 are mixed states, the Hilbert-Schmidt overlap will take values smaller than one in the optimal case. To compensate, we divide the weights by the purity of the respective states.","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"weights = Float64[20, 1, 1];\nweights *= length(weights) / sum(weights); # manual normalization\nweights ./= [0.3, 1.0, 0.25]; # purities\n\nconst objectives = [\n    Objective(\n        initial_state=reshape(ÏÌ‚â‚, :),\n        generator=L,\n        target_state=reshape(ÏÌ‚â‚_tgt, :),\n        weight=weights[1]\n    ),\n    Objective(\n        initial_state=reshape(ÏÌ‚â‚‚, :),\n        generator=L,\n        target_state=reshape(ÏÌ‚â‚‚_tgt, :),\n        weight=weights[2]\n    ),\n    Objective(\n        initial_state=reshape(ÏÌ‚â‚ƒ, :),\n        generator=L,\n        target_state=reshape(ÏÌ‚â‚ƒ_tgt, :),\n        weight=weights[3]\n    )\n];","category":"page"},{"location":"examples/rho_3states/#Dynamics-under-the-Guess-Pulse","page":"Optimization of a Dissipative Quantum Gate","title":"Dynamics under the Guess Pulse","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"ÏÌ‚â‚€â‚€ = ket(0, 0) * adjoint(ket(0, 0));\nÏÌ‚â‚€â‚ = ket(0, 1) * adjoint(ket(0, 1));\nÏÌ‚â‚â‚€ = ket(1, 0) * adjoint(ket(1, 0));\nÏÌ‚â‚â‚ = ket(1, 1) * adjoint(ket(1, 1));\n\nfunction as_matrix(Ïâƒ—)\n    N = isqrt(length(Ïâƒ—))\n    return reshape(Ïâƒ—, N, N)\nend;\n\npop00(Ïâƒ—) = real(tr(as_matrix(Ïâƒ—) * ÏÌ‚â‚€â‚€));\npop01(Ïâƒ—) = real(tr(as_matrix(Ïâƒ—) * ÏÌ‚â‚€â‚));\npop10(Ïâƒ—) = real(tr(as_matrix(Ïâƒ—) * ÏÌ‚â‚â‚€));\npop11(Ïâƒ—) = real(tr(as_matrix(Ïâƒ—) * ÏÌ‚â‚â‚));\n\n\nusing QuantumPropagators: Newton\n\nrho_00_expvals = propagate_objective(\n    objectives[1],\n    tlist;\n    initial_state=reshape(ÏÌ‚â‚€â‚€, :),\n    method=Newton,\n    observables=(pop00, pop01, pop10, pop11),\n    storage=true\n);","category":"page"},{"location":"examples/rho_3states/#Optimization","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization","text":"","category":"section"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"problem = ControlProblem(\n    objectives=objectives,\n    prop_method=Newton,\n    use_threads=true,\n    lambda_a=1.0,\n    update_shape=(t -> QuantumControl.Shapes.flattop(t, T=T, t_rise=20ns, func=:blackman)),\n    tlist=tlist,\n    iter_stop=3000,\n    J_T=QuantumControl.Functionals.J_T_re,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10â»Â³\"))\n    end\n);","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"opt_result = @optimize_or_load(\n    datadir(\"DissGateOCT#J_T=J_T_re#iter_stop=3000#method=krotov.jld2\"),\n    problem,\n    method = :krotov,\n)","category":"page"},{"location":"examples/rho_3states/","page":"Optimization of a Dissipative Quantum Gate","title":"Optimization of a Dissipative Quantum Gate","text":"Krotov Optimization Result\n--------------------------\n- Started at 2024-01-17T17:06:20.333\n- Number of objectives: 3\n- Number of iterations: 3000\n- Value of functional: 2.84800e-03\n- Reason for termination: Reached maximum number of iterations\n- Ended at 2024-01-17T21:06:26.854 (4 hours, 6 seconds, 521 milliseconds)\n","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"EditURL = \"krotov_pulse_parametrization.jl\"","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Pulse-Parametrization-for-Krotov's-Method","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"This example illustrates the parametrization of control pulses as a form of amplitude constraint.","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"datadir(names...) = joinpath(@__DIR__, names...);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"using QuantumControl\nusing QuantumControl.Shapes: flattop\nusing QuantumControl.Generators\nusing QuantumControl.Controls\nusing QuantumControl.PulseParametrizations:\n    SquareParametrization,\n    TanhParametrization,\n    TanhSqParametrization,\n    LogisticParametrization,\n    LogisticSqParametrization,\n    ParametrizedAmplitude\nusing QuantumPropagators: ExpProp\nusing LinearAlgebra","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :top,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8),\n)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Parametrizations","page":"Pulse Parametrization for Krotov's Method","title":"Parametrizations","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/#Symmetric-Bounded-Controls","page":"Pulse Parametrization for Krotov's Method","title":"Symmetric Bounded Controls","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Positive-(Bounded)-Controls","page":"Pulse Parametrization for Krotov's Method","title":"Positive (Bounded) Controls","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Two-level-Hamiltonian","page":"Pulse Parametrization for Krotov's Method","title":"Two-level Hamiltonian","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"We consider the Hamiltonian opH_0 = - fracomega2 opsigma_z, representing a simple qubit with energy level splitting omega in the basis ket0ket1. The control field epsilon(t) is assumed to couple via the Hamiltonian opH_1(t) = epsilon(t) opsigma_x to the qubit, i.e., the control field effectively drives transitions between both qubit states.","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"We we will use","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"Ïµ(t) = 0.2 * flattop(t, T=5, t_rise=0.3, func=:blackman);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"\"\"\"Two-level-system Hamiltonian.\"\"\"\nfunction tls_hamiltonian(; Î©=1.0, ampl=Ïµ)\n    ÏƒÌ‚_z = ComplexF64[\n        1  0\n        0 -1\n    ]\n    ÏƒÌ‚_x = ComplexF64[\n        0  1\n        1  0\n    ]\n    HÌ‚â‚€ = -0.5 * Î© * ÏƒÌ‚_z\n    HÌ‚â‚ = ÏƒÌ‚_x\n    return hamiltonian(HÌ‚â‚€, (HÌ‚â‚, ampl))\nend;","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"H = tls_hamiltonian();","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"The control field here switches on from zero at t=0 to it's maximum amplitude 0.2 within the time period 0.3 (the switch-on shape is half a Blackman pulse). It switches off again in the time period 0.3 before the final time T=5). We use a time grid with 500 time steps between 0 and T:","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"tlist = collect(range(0, 5, length=500));","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"function plot_amplitude(ampl, tlist)\n    plot(tlist, discretize(ampl, tlist), xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nfig = plot_amplitude(Ïµ, tlist)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Optimization-target","page":"Pulse Parametrization for Krotov's Method","title":"Optimization target","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"The krotov package requires the goal of the optimization to be described by a list of Objective instances. In this example, there is only a single objective: the state-to-state transfer from initial state ketPsi_init = ket0 to the target state ketPsi_tgt = ket1, under the dynamics of the Hamiltonian opH(t):","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"function ket(label)\n    result = Dict(\"0\" => Vector{ComplexF64}([1, 0]), \"1\" => Vector{ComplexF64}([0, 1]),)\n    return result[string(label)]\nend;","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"objectives = [Objective(initial_state=ket(0), generator=H, target_state=ket(1))]","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"1-element Vector{QuantumControlBase.Objective{Vector{ComplexF64}, QuantumPropagators.Generators.Generator{Matrix{ComplexF64}, typeof(Main.var\"##225\".Ïµ)}}}:\n Objective{Vector{ComplexF64}, QuantumPropagators.Generators.Generator{Matrix{ComplexF64}, typeof(Main.var\"##225\".Ïµ)}}(â€¦)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Square-parametrization-for-positive-pulses","page":"Pulse Parametrization for Krotov's Method","title":"Square-parametrization for positive pulses","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"a = ParametrizedAmplitude(\n    Ïµ,\n    tlist;\n    parametrization=SquareParametrization(),\n    parameterize=true\n)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"ParametrizedAmplitude(::Vector{Float64}; parametrization=SquareParametrization())","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"function plot_amplitude(ampl::ParametrizedAmplitude, tlist)\n    plot(\n        tlist,\n        discretize(Array(ampl), tlist),\n        xlabel=\"time\",\n        ylabel=\"amplitude\",\n        legend=false\n    )\nend\n\nfig = plot_amplitude(a, tlist)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"problem = ControlProblem(\n    objectives=substitute(objectives, IdDict(Ïµ => a)),\n    prop_method=ExpProp,\n    lambda_a=5,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10â»Â³\"))\n    end\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"opt_result_positive = @optimize_or_load(\n    datadir(\"parametrization#opt_result_positive.jld2\"),\n    problem;\n    method=:krotov\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":" iter.        J_T   âˆ«gâ‚(t)dt          J       Î”J_T         Î”J    secs\n     0   9.51e-01   0.00e+00   9.51e-01        n/a        n/a     4.9\n[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/tutorials/krotov_pulse_parametrization/parametrization#opt_result_positive.jld2 on unexpected exit.\n     1   9.31e-01   9.29e-03   9.40e-01  -2.05e-02  -1.12e-02     2.3\n     2   9.01e-01   1.34e-02   9.15e-01  -2.96e-02  -1.63e-02     0.0\n     3   8.59e-01   1.91e-02   8.78e-01  -4.25e-02  -2.34e-02     0.0\n     4   7.99e-01   2.67e-02   8.26e-01  -5.96e-02  -3.29e-02     0.0\n     5   7.20e-01   3.56e-02   7.56e-01  -7.91e-02  -4.35e-02     0.0\n     6   6.25e-01   4.33e-02   6.68e-01  -9.52e-02  -5.19e-02     0.0\n     7   5.25e-01   4.62e-02   5.72e-01  -9.96e-02  -5.33e-02     0.0\n     8   4.36e-01   4.25e-02   4.79e-01  -8.92e-02  -4.66e-02     0.0\n     9   3.65e-01   3.49e-02   4.00e-01  -7.14e-02  -3.64e-02     0.0\n    10   3.10e-01   2.74e-02   3.37e-01  -5.48e-02  -2.74eâ€¦\n    37   5.05e-02   8.59e-04   5.13e-02  -1.70e-03  -8.45e-04     0.0\n    38   4.89e-02   8.05e-04   4.97e-02  -1.60e-03  -7.93e-04     0.0\n    39   4.74e-02   7.56e-04   4.81e-02  -1.50e-03  -7.45e-04     0.0\n    40   4.60e-02   7.12e-04   4.67e-02  -1.41e-03  -7.02e-04     0.0\n    41   4.46e-02   6.71e-04   4.53e-02  -1.33e-03  -6.62e-04     0.0\n    42   4.34e-02   6.34e-04   4.40e-02  -1.26e-03  -6.26e-04     0.0\n    43   4.22e-02   5.99e-04   4.28e-02  -1.19e-03  -5.92e-04     0.0\n    44   4.11e-02   5.68e-04   4.16e-02  -1.13e-03  -5.61e-04     0.0\n    45   4.00e-02   5.38e-04   4.05e-02  -1.07e-03  -5.32e-04     0.0\n    46   3.90e-02   5.11e-04   3.95e-02  -1.02e-03  -5.06e-04     0.0\n    47   3.80e-02   4.86e-04   3.85e-02  -9.67e-04  -4.81e-04     0.0\n    48   3.71e-02   4.63e-04   3.75e-02  -9.21e-04  -4.58e-04     0.0\n    49   3.62e-02   4.41e-04   3.66e-02  -8.78e-04  -4.37e-04     0.0\n    50   3.54e-02   4.21e-04   3.58e-02  -8.38e-04  -4.17e-04     0.0\n\n","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"opt_result_positive","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"Krotov Optimization Result\n--------------------------\n- Started at 2024-01-17T21:07:41.380\n- Number of objectives: 1\n- Number of iterations: 50\n- Value of functional: 3.53585e-02\n- Reason for termination: Reached maximum number of iterations\n- Ended at 2024-01-17T21:07:48.976 (7 seconds, 596 milliseconds)\n","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"We can plot the optimized field:","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"fig = plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_positive.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Tanh-Square-Parametrization-for-positive-amplitude-constrained-pulses","page":"Pulse Parametrization for Krotov's Method","title":"Tanh-Square-Parametrization for positive amplitude-constrained pulses","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"a = ParametrizedAmplitude(\n    Ïµ,\n    tlist;\n    parametrization=TanhSqParametrization(3),\n    parameterize=true\n)\n\nproblem_tanhsq = ControlProblem(\n    objectives=substitute(objectives, IdDict(Ïµ => a)),\n    prop_method=ExpProp,\n    lambda_a=10,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10â»Â³\"))\n    end\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"opt_result_tanhsq = @optimize_or_load(\n    datadir(\"parametrization#opt_result_tanhsq.jld2\"),\n    problem_tanhsq;\n    method=:krotov\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":" iter.        J_T   âˆ«gâ‚(t)dt          J       Î”J_T         Î”J    secs\n     0   9.51e-01   0.00e+00   9.51e-01        n/a        n/a     0.1\n[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/tutorials/krotov_pulse_parametrization/parametrization#opt_result_tanhsq.jld2 on unexpected exit.\n     1   9.24e-01   1.21e-02   9.36e-01  -2.76e-02  -1.54e-02     0.0\n     2   8.81e-01   1.90e-02   9.00e-01  -4.32e-02  -2.42e-02     0.0\n     3   8.15e-01   2.88e-02   8.44e-01  -6.54e-02  -3.65e-02     0.0\n     4   7.24e-01   4.06e-02   7.65e-01  -9.08e-02  -5.02e-02     0.0\n     5   6.16e-01   4.99e-02   6.65e-01  -1.09e-01  -5.90e-02     0.0\n     6   5.08e-01   5.11e-02   5.59e-01  -1.08e-01  -5.66e-02     0.0\n     7   4.19e-01   4.38e-02   4.62e-01  -8.92e-02  -4.54e-02     0.0\n     8   3.52e-01   3.37e-02   3.85e-01  -6.69e-02  -3.33e-02     0.0\n     9   3.02e-01   2.51e-02   3.28e-01  -4.92e-02  -2.41e-02     0.0\n    10   2.66e-01   1.89e-02   2.84e-01  -3.69e-02  -1.79e-0â€¦\n    37   8.06e-02   7.52e-04   8.14e-02  -1.49e-03  -7.37e-04     0.0\n    38   7.92e-02   7.10e-04   8.00e-02  -1.41e-03  -6.96e-04     0.0\n    39   7.79e-02   6.72e-04   7.86e-02  -1.33e-03  -6.59e-04     0.0\n    40   7.67e-02   6.36e-04   7.73e-02  -1.26e-03  -6.24e-04     0.0\n    41   7.55e-02   6.03e-04   7.61e-02  -1.20e-03  -5.92e-04     0.0\n    42   7.43e-02   5.73e-04   7.49e-02  -1.14e-03  -5.63e-04     0.0\n    43   7.32e-02   5.45e-04   7.38e-02  -1.08e-03  -5.35e-04     0.0\n    44   7.22e-02   5.19e-04   7.27e-02  -1.03e-03  -5.10e-04     0.0\n    45   7.12e-02   4.95e-04   7.17e-02  -9.81e-04  -4.87e-04     0.0\n    46   7.03e-02   4.72e-04   7.08e-02  -9.37e-04  -4.65e-04     0.0\n    47   6.94e-02   4.52e-04   6.98e-02  -8.96e-04  -4.44e-04     0.0\n    48   6.85e-02   4.32e-04   6.90e-02  -8.57e-04  -4.25e-04     0.0\n    49   6.77e-02   4.14e-04   6.81e-02  -8.21e-04  -4.07e-04     0.0\n    50   6.69e-02   3.97e-04   6.73e-02  -7.87e-04  -3.91e-04     0.0\n\n","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"opt_result_tanhsq","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"Krotov Optimization Result\n--------------------------\n- Started at 2024-01-17T21:07:52.043\n- Number of objectives: 1\n- Number of iterations: 50\n- Value of functional: 6.69321e-02\n- Reason for termination: Reached maximum number of iterations\n- Ended at 2024-01-17T21:07:52.575 (532 milliseconds)\n","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"We can plot the optimized field:","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"fig = plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_tanhsq.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Logistic-Square-Parametrization-for-positive-amplitude-constrained-pulses","page":"Pulse Parametrization for Krotov's Method","title":"Logistic-Square-Parametrization for positive amplitude-constrained pulses","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"a = ParametrizedAmplitude(\n    Ïµ,\n    tlist;\n    parametrization=LogisticSqParametrization(3, k=1.0),\n    parameterize=true\n)\n\nproblem_logisticsq = ControlProblem(\n    objectives=substitute(objectives, IdDict(Ïµ => a)),\n    prop_method=ExpProp,\n    lambda_a=1,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10â»Â³\"))\n    end\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"opt_result_logisticsq = @optimize_or_load(\n    datadir(\"parametrization#opt_result_logisticsq.jld2\"),\n    problem_logisticsq;\n    method=:krotov\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":" iter.        J_T   âˆ«gâ‚(t)dt          J       Î”J_T         Î”J    secs\n     0   9.51e-01   0.00e+00   9.51e-01        n/a        n/a     0.1\n[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/tutorials/krotov_pulse_parametrization/parametrization#opt_result_logisticsq.jld2 on unexpected exit.\n     1   8.72e-01   2.97e-02   9.02e-01  -7.91e-02  -4.93e-02     0.0\n     2   6.93e-01   6.94e-02   7.63e-01  -1.79e-01  -1.10e-01     0.0\n     3   4.57e-01   1.03e-01   5.60e-01  -2.36e-01  -1.33e-01     0.0\n     4   3.07e-01   7.51e-02   3.82e-01  -1.50e-01  -7.49e-02     0.0\n     5   2.31e-01   4.00e-02   2.71e-01  -7.60e-02  -3.60e-02     0.0\n     6   1.87e-01   2.31e-02   2.10e-01  -4.37e-02  -2.06e-02     0.0\n     7   1.59e-01   1.48e-02   1.74e-01  -2.82e-02  -1.34e-02     0.0\n     8   1.39e-01   1.03e-02   1.49e-01  -1.97e-02  -9.38e-03     0.0\n     9   1.25e-01   7.53e-03   1.32e-01  -1.45e-02  -6.93e-03     0.0\n    10   1.14e-01   5.74e-03   1.19e-01  -1.11e-02  -5.3â€¦\n    37   4.98e-02   3.05e-04   5.01e-02  -6.03e-04  -2.99e-04     0.0\n    38   4.92e-02   2.88e-04   4.95e-02  -5.71e-04  -2.83e-04     0.0\n    39   4.87e-02   2.74e-04   4.89e-02  -5.42e-04  -2.68e-04     0.0\n    40   4.81e-02   2.60e-04   4.84e-02  -5.15e-04  -2.55e-04     0.0\n    41   4.76e-02   2.47e-04   4.79e-02  -4.90e-04  -2.43e-04     0.0\n    42   4.72e-02   2.35e-04   4.74e-02  -4.66e-04  -2.31e-04     0.0\n    43   4.67e-02   2.24e-04   4.70e-02  -4.45e-04  -2.20e-04     0.0\n    44   4.63e-02   2.14e-04   4.65e-02  -4.25e-04  -2.11e-04     0.0\n    45   4.59e-02   2.05e-04   4.61e-02  -4.06e-04  -2.01e-04     0.0\n    46   4.55e-02   1.96e-04   4.57e-02  -3.88e-04  -1.93e-04     0.0\n    47   4.51e-02   1.87e-04   4.53e-02  -3.72e-04  -1.84e-04     0.0\n    48   4.48e-02   1.80e-04   4.50e-02  -3.57e-04  -1.77e-04     0.0\n    49   4.44e-02   1.72e-04   4.46e-02  -3.42e-04  -1.70e-04     0.0\n    50   4.41e-02   1.66e-04   4.43e-02  -3.29e-04  -1.63e-04     0.0\n\n","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"We can plot the optimized field:","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"fig = plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_logisticsq.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/#Tanh-parametrization-for-amplitude-constrained-pulses","page":"Pulse Parametrization for Krotov's Method","title":"Tanh-parametrization for amplitude-constrained pulses","text":"","category":"section"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"a = ParametrizedAmplitude(\n    Ïµ,\n    tlist;\n    parametrization=TanhParametrization(-0.5, 0.5),\n    parameterize=true\n)\n\nproblem_tanh = ControlProblem(\n    objectives=substitute(objectives, IdDict(Ïµ => a)),\n    prop_method=ExpProp,\n    lambda_a=1,\n    update_shape=(t -> flattop(t, T=5, t_rise=0.3, func=:blackman)),\n    tlist=tlist,\n    iter_stop=50,\n    J_T=QuantumControl.Functionals.J_T_ss,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10â»Â³\"))\n    end\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"opt_result_tanh = @optimize_or_load(\n    datadir(\"parametrization#opt_result_tanh.jld2\"),\n    problem_tanh;\n    method=:krotov\n);","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":" iter.        J_T   âˆ«gâ‚(t)dt          J       Î”J_T         Î”J    secs\n     0   9.51e-01   0.00e+00   9.51e-01        n/a        n/a     0.1\n[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/tutorials/krotov_pulse_parametrization/parametrization#opt_result_tanh.jld2 on unexpected exit.\n     1   9.27e-01   1.09e-02   9.38e-01  -2.40e-02  -1.31e-02     0.0\n     2   8.93e-01   1.56e-02   9.09e-01  -3.42e-02  -1.87e-02     0.0\n     3   8.46e-01   2.18e-02   8.67e-01  -4.77e-02  -2.59e-02     0.0\n     4   7.82e-01   2.94e-02   8.11e-01  -6.37e-02  -3.43e-02     0.0\n     5   7.03e-01   3.70e-02   7.40e-01  -7.89e-02  -4.18e-02     0.0\n     6   6.16e-01   4.18e-02   6.58e-01  -8.68e-02  -4.50e-02     0.0\n     7   5.33e-01   4.12e-02   5.74e-01  -8.33e-02  -4.21e-02     0.0\n     8   4.62e-01   3.59e-02   4.98e-01  -7.11e-02  -3.52e-02     0.0\n     9   4.05e-01   2.89e-02   4.34e-01  -5.66e-02  -2.77e-02     0.0\n    10   3.61e-01   2.26e-02   3.84e-01  -4.40e-02  -2.14e-02 â€¦\n    37   1.35e-01   9.69e-04   1.36e-01  -1.92e-03  -9.52e-04     0.0\n    38   1.33e-01   9.17e-04   1.34e-01  -1.82e-03  -9.02e-04     0.0\n    39   1.31e-01   8.70e-04   1.32e-01  -1.73e-03  -8.56e-04     0.0\n    40   1.29e-01   8.26e-04   1.30e-01  -1.64e-03  -8.13e-04     0.0\n    41   1.28e-01   7.86e-04   1.29e-01  -1.56e-03  -7.74e-04     0.0\n    42   1.26e-01   7.49e-04   1.27e-01  -1.49e-03  -7.38e-04     0.0\n    43   1.25e-01   7.14e-04   1.26e-01  -1.42e-03  -7.04e-04     0.0\n    44   1.24e-01   6.82e-04   1.24e-01  -1.35e-03  -6.73e-04     0.0\n    45   1.22e-01   6.52e-04   1.23e-01  -1.30e-03  -6.43e-04     0.0\n    46   1.21e-01   6.24e-04   1.22e-01  -1.24e-03  -6.16e-04     0.0\n    47   1.20e-01   5.98e-04   1.21e-01  -1.19e-03  -5.91e-04     0.0\n    48   1.19e-01   5.74e-04   1.19e-01  -1.14e-03  -5.67e-04     0.0\n    49   1.18e-01   5.51e-04   1.18e-01  -1.10e-03  -5.45e-04     0.0\n    50   1.17e-01   5.30e-04   1.17e-01  -1.05e-03  -5.24e-04     0.0\n\n","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"fig = plot_amplitude(\n    substitute(a, IdDict(a.control => opt_result_tanh.optimized_controls[1])),\n    tlist\n)","category":"page"},{"location":"tutorials/krotov_pulse_parametrization/","page":"Pulse Parametrization for Krotov's Method","title":"Pulse Parametrization for Krotov's Method","text":"(Image: )","category":"page"},{"location":"examples/#List-of-Examples","page":"List of Examples","title":"List of Examples","text":"","category":"section"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"# if we ever need something fancier than @contents, e.g., including\n# tags, the following provides a starting point:\nusing Markdown\n\nlines = []\nfor (title, index_md) in Main.EXAMPLES\n    folder = splitpath(index_md)[2]\n    push!(lines, \"* [$title]($folder/)\")\nend\nMarkdown.parse(join(lines, \"\\n\"))\nnothing # XXX","category":"page"},{"location":"examples/","page":"List of Examples","title":"List of Examples","text":"Pages = [index_md for (title, index_md) in EXAMPLES]\nDepth = 1","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"EditURL = \"simple_state_to_state.jl\"","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-of-a-State-to-State-Transfer-in-a-Two-Level-System","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"gdefop1hat1 gdefinittextinit gdeftgttexttgt","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"This first example illustrates the basic use of the GRAPE.jl by solving a simple canonical optimization problem: the transfer of population in a two level system.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"datadir(names...) = joinpath(@__DIR__, names...)\n\nusing QuantumControl\nusing QuantumPropagators: ExpProp","category":"page"},{"location":"examples/simple_state_to_state/#Two-level-Hamiltonian","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Two-level Hamiltonian","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"We consider the Hamiltonian opH_0 = - fracomega2 opsigma_z, representing a simple qubit with energy level splitting omega in the basis ket0ket1. The control field epsilon(t) is assumed to couple via the Hamiltonian opH_1(t) = epsilon(t) opsigma_x to the qubit, i.e., the control field effectively drives transitions between both qubit states.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"We we will use","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"Ïµ(t) = 0.2 * QuantumControl.Shapes.flattop(t, T=5, t_rise=0.3, func=:blackman);","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"\"\"\"Two-level-system Hamiltonian.\"\"\"\nfunction tls_hamiltonian(Î©=1.0, Ïµ=Ïµ)\n    ÏƒÌ‚_z = ComplexF64[\n        1  0\n        0 -1\n    ]\n    ÏƒÌ‚_x = ComplexF64[\n        0  1\n        1  0\n    ]\n    HÌ‚â‚€ = -0.5 * Î© * ÏƒÌ‚_z\n    HÌ‚â‚ = ÏƒÌ‚_x\n    return hamiltonian(HÌ‚â‚€, (HÌ‚â‚, Ïµ))\nend;","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"H = tls_hamiltonian();","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"The control field here switches on from zero at t=0 to it's maximum amplitude 0.2 within the time period 0.3 (the switch-on shape is half a Blackman pulse). It switches off again in the time period 0.3 before the final time T=5). We use a time grid with 500 time steps between 0 and T:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"tlist = collect(range(0, 5, length=500));","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"using Plots\nPlots.default(\n    linewidth               = 3,\n    size                    = (550, 300),\n    legend                  = :right,\n    foreground_color_legend = nothing,\n    background_color_legend = RGBA(1, 1, 1, 0.8)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"function plot_control(pulse::Vector, tlist)\n    plot(tlist, pulse, xlabel=\"time\", ylabel=\"amplitude\", legend=false)\nend\n\nplot_control(Ïµ::Function, tlist) = plot_control([Ïµ(t) for t in tlist], tlist);","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"fig = plot_control(Ïµ, tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"(Image: )","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-target","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization target","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"First, we define a convenience function for the eigenstates.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"function ket(label)\n    result = Dict(\"0\" => Vector{ComplexF64}([1, 0]), \"1\" => Vector{ComplexF64}([0, 1]))\n    return result[string(label)]\nend;","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"The physical objective of our optimization is to transform the initial state ket0 into the target state ket1 under the time evolution induced by the Hamiltonian opH(t).","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"objectives = [Objective(initial_state=ket(0), generator=H, target_state=ket(1))];","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"The full control problem includes this objective, information about the time grid for the dynamics, and the functional to be used (the square modulus of the overlap tau with the target state in this case).","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"using QuantumControl.Functionals: J_T_sm\n\nproblem = ControlProblem(\n    objectives=objectives,\n    tlist=tlist,\n    iter_stop=500,\n    prop_method=ExpProp,\n    pulse_options=Dict(),\n    J_T=J_T_sm,\n    check_convergence=res -> begin\n        ((res.J_T < 1e-3) && (res.converged = true) && (res.message = \"J_T < 10â»Â³\"))\n    end,\n);","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-dynamics-under-the-guess-field","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Simulate dynamics under the guess field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"Before running the optimization procedure, we first simulate the dynamics under the guess field epsilon_0(t). The following solves equation of motion for the defined objective, which contains the initial state ketPsi_init and the Hamiltonian opH(t) defining its evolution.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"guess_dynamics = propagate_objective(\n    objectives[1],\n    problem.tlist;\n    method=ExpProp,\n    storage=true,\n    observables=(Î¨ -> abs.(Î¨) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"2Ã—500 Matrix{Float64}:\n 1.0  1.0          1.0          1.0          â€¦  0.951457   0.951459  0.951459\n 0.0  7.73456e-40  2.03206e-11  2.96638e-10     0.0485427  0.048541  0.048541","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"function plot_population(pop0::Vector, pop1::Vector, tlist)\n    fig = plot(tlist, pop0, label=\"0\", xlabel=\"time\", ylabel=\"population\")\n    plot!(fig, tlist, pop1; label=\"1\")\nend;","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"fig = plot_population(guess_dynamics[1, :], guess_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"(Image: )","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-with-LBFGSB","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization with LBFGSB","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"In the following we optimize the guess field epsilon_0(t) such that the intended state-to-state transfer ketPsi_init rightarrow ketPsi_tgt is solved.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"The GRAPE package performs the optimization by calculating the gradient of J_T with respect to the values of the control field at each point in time. This gradient is then fed into a backend solver that calculates an appropriate update based on that gradient.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"By default, this backend is LBFGSB.jl, a wrapper around the true and tested L-BFGS-B Fortran library. L-BFGS-B is a pseudo-Hessian method: it efficiently estimates the second-order Hessian from the gradient information. The search direction determined from that Hessian dramatically improves convergence compared to using the gradient directly as a search direction. The L-BFGS-B method performs its own linesearch to determine how far to go in the search direction.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"It can be quite instructive to see how the improvement in the pseudo-Hessian search direction compares to the gradient, how the linesearch finds an appropriate step width. For this purpose, we have a GRAPELinesearchAnalysis package that automatically generates plots in every iteration of the optimization showing the linesearch behavior","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"using GRAPELinesearchAnalysis","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"We feed this into the optimization as part of the info_hook.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"opt_result_LBFGSB = @optimize_or_load(\n    datadir(\"TLS\", \"GRAPE_opt_result_LBFGSB.jld2\"),\n    problem;\n    method=:grape,\n    prop_method=ExpProp,\n    force=true,\n    info_hook=(\n        GRAPELinesearchAnalysis.plot_linesearch(datadir(\"TLS\", \"Linesearch\", \"LBFGSB\")),\n        QuantumControl.GRAPE.print_table,\n    )\n);","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/examples/grape_state_to_state/TLS/GRAPE_opt_result_LBFGSB.jld2 on unexpected exit.\n iter.        J_T     |âˆ‡J_T|       Î”J_T   FG(F)    secs\n     0   9.51e-01   5.40e-02        n/a    1(0)     4.3\n     1   9.49e-01   5.55e-02  -2.95e-03    1(0)     1.0\n     2   3.94e-02   6.30e-02  -9.09e-01    6(0)     1.9\n     3   1.65e-02   3.82e-02  -2.29e-02    2(0)     1.1\n     4   1.27e-02   3.35e-02  -3.84e-03    1(0)     0.9\n     5   1.65e-05   1.31e-03  -1.27e-02    1(0)     0.9\n","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"When going through this tutorial locally, the generated images for the linesearch can be found in datadir(\"TLS\", \"Linesearch, \"LBFGS\")","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"opt_result_LBFGSB","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"GRAPE Optimization Result\n-------------------------\n- Started at 2024-01-17T16:36:58.094\n- Number of objectives: 1\n- Number of iterations: 5\n- Number of pure func evals: 0\n- Number of func/grad evals: 12\n- Value of functional: 1.65005e-05\n- Reason for termination: J_T < 10â»Â³\n- Ended at 2024-01-17T16:37:09.011 (10 seconds, 917 milliseconds)\n","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"fig = plot_control(opt_result_LBFGSB.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"(Image: )","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-via-semi-automatic-differentiation","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization via semi-automatic differentiation","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"Our GRAPE implementation includes the analytic gradient of the optimization functional J_T_sm. Thus, we only had to pass the functional itself to the optimization. More generally, for functionals where the analytic gradient is not known, semi-automatic differentiation can be used to determine it automatically. For illustration, we may re-run the optimization forgoing the known analytic gradient and instead using an automatically determined gradient.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"As shown in Goerz et al., arXiv:2205.15044, by evaluating the gradient of J_T via a chain rule in the propagated states, the dependency of the gradient on the final time functional is pushed into the boundary condition for the backward propagation, Ï‡_k = -J_TÏ•_k. For functionals that can be written in terms of the overlaps Ï„_k of the forward-propagated states and target states, such as the J_T_sm used here, a further chain rule leaves derivatives of J_T with respect to the overlaps Ï„_k, which are easily obtained via automatic differentiation. This happens automatically if we use make_chi with force_zygote=true and pass the resulting chi to the optimization:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"using QuantumControl.Functionals: make_chi\n\nchi_sm = make_chi(J_T_sm, objectives; force_zygote=true)\n\nopt_result_LBFGSB_via_Ï‡ = optimize(problem; method=:grape, chi=chi_sm);","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":" iter.        J_T     |âˆ‡J_T|       Î”J_T   FG(F)    secs\n     0   9.51e-01   5.40e-02        n/a    1(0)    14.3\n     1   9.49e-01   5.55e-02  -2.95e-03    1(0)     0.0\n     2   3.94e-02   6.30e-02  -9.09e-01    6(0)     0.1\n     3   1.65e-02   3.82e-02  -2.29e-02    2(0)     0.0\n     4   1.27e-02   3.35e-02  -3.84e-03    1(0)     0.0\n     5   1.65e-05   1.31e-03  -1.27e-02    1(0)     0.0\n","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"opt_result_LBFGSB_via_Ï‡","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"GRAPE Optimization Result\n-------------------------\n- Started at 2024-01-17T16:37:12.569\n- Number of objectives: 1\n- Number of iterations: 5\n- Number of pure func evals: 0\n- Number of func/grad evals: 12\n- Value of functional: 1.65005e-05\n- Reason for termination: J_T < 10â»Â³\n- Ended at 2024-01-17T16:37:27.015 (14 seconds, 446 milliseconds)\n","category":"page"},{"location":"examples/simple_state_to_state/#Optimization-with-Optim.jl","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization with Optim.jl","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"As an alternative to the default L-BFGS-B backend, we can also use any of the gradient-based optimizers in Optiml.jl. This also gives full control over the linesearch method.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"import Optim\nimport LineSearches","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"Here, we use the LBFGS implementation that is part of Optim (which is not exactly the same as L-BFGS-B; \"B\" being the variant of LBFGS with optional additional bounds on the control) with a Hager-Zhang linesearch","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"opt_result_OptimLBFGS = @optimize_or_load(\n    datadir(\"TLS\", \"GRAPE_opt_result_OptimLBFGS.jld2\"),\n    problem;\n    method=:grape,\n    force=true,\n    info_hook=(\n        GRAPELinesearchAnalysis.plot_linesearch(datadir(\"TLS\", \"Linesearch\", \"OptimLBFGS\")),\n        QuantumControl.GRAPE.print_table,\n    ),\n    optimizer=Optim.LBFGS(;\n        alphaguess=LineSearches.InitialStatic(alpha=0.2),\n        linesearch=LineSearches.HagerZhang(alphamax=2.0)\n    )\n);","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"[ Info: Set callback to store result in /storage/goerz/nobackup/QuantumControlExamples.jl/examples/grape_state_to_state/TLS/GRAPE_opt_result_OptimLBFGS.jld2 on unexpected exit.\n iter.        J_T     |âˆ‡J_T|       Î”J_T   FG(F)    secs\n     0   9.51e-01   5.40e-02        n/a    1(0)     1.6\n     1   9.45e-01   5.71e-02  -5.99e-03    3(0)     0.2\n     2   9.39e-01   6.04e-02  -6.72e-03    3(0)     0.9\n     3   9.31e-01   6.39e-02  -7.52e-03    3(0)     0.9\n     4   9.23e-01   6.76e-02  -8.41e-03    3(0)     0.9\n     5   9.13e-01   7.14e-02  -9.39e-03    3(0)     0.9\n     6   9.03e-01   7.53e-02  -1.05e-02    3(0)     0.9\n     7   8.91e-01   7.94e-02  -1.16e-02    3(0)     0.9\n     8   8.78e-01   8.35e-02  -1.29e-02    3(0)     0.8\n     9   8.64e-01   8.78e-02  -1.43e-02    3(0)     0.9\n    10   8.48e-01   9.22e-02  -1.58e-02    3(0)     0.9\n    11   8.31e-01   9.66e-02  -1.74e-02    3(0)     0.9\n    12   8.12e-01   1.01e-01  -1.91e-02    3(0)     0.9\n    13   7.91e-01   1.05e-01  -2.08e-02    3(0)     0.8\n    14   7.68e-01   1.10e-01  -2.26e-02    3(0)     0.9\n    15   7.44e-01   1.14e-01  -2.45e-02    3(0)     0.9\n    16   7.18e-01   1.17e-01  -2.63e-02    3(0)     0.9\n    17   6.90e-01   1.21e-01  -2.80e-02    3(0)     0.9\n    18   6.60e-01   1.24e-01  -2.97e-02    3(0)     0.9\n    19   6.29e-01   1.27e-01  -3.12e-02    3(0)     0.9\n    20   5.96e-01   1.29e-01  -3.26e-02    3(0)     0.9\n    21   5.62e-01   1.31e-01  -3.37e-02    3(0)     0.9\n    22   5.28e-01   1.32e-01  -3.45e-02    3(0)     0.9\n    23   4.93e-01   1.33e-01  -3.50e-02    3(0)     0.9\n    24   4.58e-01   1.32e-01  -3.51e-02    3(0)     0.8\n    25   7.25e-02   4.32e-02  -3.85e-01    2(0)     0.8\n    26   1.68e-02   4.51e-02  -5.57e-02    2(0)     0.8\n    27   2.50e-05   1.25e-03  -1.68e-02    3(0)     0.9\n","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"opt_result_OptimLBFGS","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"GRAPE Optimization Result\n-------------------------\n- Started at 2024-01-17T16:37:27.356\n- Number of objectives: 1\n- Number of iterations: 27\n- Number of pure func evals: 0\n- Number of func/grad evals: 80\n- Value of functional: 2.49647e-05\n- Reason for termination: J_T < 10â»Â³\n- Ended at 2024-01-17T16:37:52.347 (24 seconds, 991 milliseconds)\n","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"We can plot the optimized field:","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"fig = plot_control(opt_result_OptimLBFGS.optimized_controls[1], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"(Image: )","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"We can see that the choice of linesearch parameters in particular strongly influence the convergence and the resulting field. Play around with different methods and parameters, and compare the different plots generated by GRAPELinesearchAnalysis!","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"Empirically, we find the default L-BFGS-B to have a very well-behaved linesearch.","category":"page"},{"location":"examples/simple_state_to_state/#Simulate-the-dynamics-under-the-optimized-field","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Simulate the dynamics under the optimized field","text":"","category":"section"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"Having obtained the optimized control field, we can simulate the dynamics to verify that the optimized field indeed drives the initial state ketPsi_init = ket0 to the desired target state ketPsi_tgt = ket1.","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"using QuantumControl.Controls: substitute\n\nopt_dynamics = propagate_objective(\n    substitute(objectives[1], IdDict(Ïµ => opt_result_LBFGSB.optimized_controls[1])),\n    problem.tlist;\n    method=ExpProp,\n    storage=true,\n    observables=(Î¨ -> abs.(Î¨) .^ 2,)\n)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"2Ã—500 Matrix{Float64}:\n 1.0  0.99994     0.999762     â€¦  0.000174609  3.65549e-5  1.65005e-5\n 0.0  5.96719e-5  0.000237653     0.999825     0.999963    0.999983","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"fig = plot_population(opt_dynamics[1, :], opt_dynamics[2, :], tlist)","category":"page"},{"location":"examples/simple_state_to_state/","page":"Optimization of a State-to-State Transfer in a Two-Level-System","title":"Optimization of a State-to-State Transfer in a Two-Level-System","text":"(Image: )","category":"page"},{"location":"#JuliaQuantumControl-Tutorials-and-Examples","page":"Home","title":"JuliaQuantumControl Tutorials and Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This website collects Tutorials and Examples for packages in the JuliaQuantumControl organization","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tutorials are intended to teach a particular aspect of quantum control or the QuantumControl.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [index_md for (title, index_md) in TUTORIALS]\nDepth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples showcase the use of the QuantumControl.jl package for a particular optimization problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [index_md for (title, index_md) in EXAMPLES]\nDepth = 1","category":"page"}]
}
